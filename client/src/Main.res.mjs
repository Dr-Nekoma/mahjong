// Generated by ReScript, PLEASE EDIT WITH CARE

import * as WebGL from "./WebGL.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

var vsSource = "\n    attribute vec4 aVertexPosition;\n    uniform mat4 uModelViewMatrix;\n    uniform mat4 uProjectionMatrix;\n    void main() {\n      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n    }\n";

var fsSource = "\n  void main() {\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n  }\n";

function loadShader(gl, typ, src) {
  var shader = WebGL.GL.Shader.create(gl, typ);
  if (shader !== undefined) {
    var shader$1 = Caml_option.valFromOption(shader);
    WebGL.GL.Shader.source(gl, shader$1, src);
    WebGL.GL.Shader.compile(gl, shader$1);
    if (WebGL.GL.Shader.getParameter(gl, shader$1, WebGL.GL.Shader.compileStatus(gl))) {
      return Caml_option.some(shader$1);
    } else {
      console.log("Failed in getParameter function call");
      WebGL.GL.Shader.$$delete(gl, shader$1);
      return ;
    }
  }
  console.log("Unable to create shader.");
}

function initShaderProgram(gl, vsSource, fsSource) {
  var vertexShaderMay = loadShader(gl, WebGL.GL.Shader.vertex(gl), vsSource);
  var fragmentShaderMay = loadShader(gl, WebGL.GL.Shader.fragment(gl), fsSource);
  if (vertexShaderMay !== undefined) {
    if (fragmentShaderMay !== undefined) {
      var shaderProgram = WebGL.GL.Program.create(gl);
      WebGL.GL.attachShader(gl, shaderProgram, Caml_option.valFromOption(vertexShaderMay));
      WebGL.GL.attachShader(gl, shaderProgram, Caml_option.valFromOption(fragmentShaderMay));
      WebGL.GL.Program.link(gl, shaderProgram);
      if (WebGL.GL.Program.getParameter(gl, shaderProgram, WebGL.GL.Shader.linkStatus(gl))) {
        return Caml_option.some(shaderProgram);
      } else {
        console.log("Failed in getParameter function call");
        return ;
      }
    }
    console.log("Failed creating shaders");
    return ;
  }
  console.log("Failed creating shaders");
}

function main() {
  var canvasMay = WebGL.DOM.querySelector("canvas");
  if (canvasMay !== undefined) {
    var glMay = WebGL.DOM.getContext(Caml_option.valFromOption(canvasMay), "webgl");
    if (glMay !== undefined) {
      var gl = Caml_option.valFromOption(glMay);
      console.log(gl);
      WebGL.GL.clearColor(gl, 0.0, 0.0, 0.0, 1.0);
      WebGL.GL.clear(gl, WebGL.GL.Buffers.colorBufferBit(gl));
      var shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      if (shaderProgram !== undefined) {
        var shaderProgram$1 = Caml_option.valFromOption(shaderProgram);
        ({
            program: shaderProgram$1,
            attribLocations: {
              vertexPosition: WebGL.GL.Program.getAttribLocation(gl, shaderProgram$1, "aVertexPosition")
            },
            uniformLocations: {
              projectionMatrix: Core__Option.getExn(WebGL.GL.Program.getUniformLocation(gl, shaderProgram$1, "uProjectionMatrix"), undefined),
              modelViewMatrix: Core__Option.getExn(WebGL.GL.Program.getUniformLocation(gl, shaderProgram$1, "uModelViewMatrix"), undefined)
            }
          });
        return ;
      }
      console.log("Could not init shader program");
      return ;
    }
    console.log("Unable to initialize WebGL. Your browser or machine may not support it.");
    return ;
  }
  console.log("Unable to initialize the canvas.");
}

main();

export {
  vsSource ,
  fsSource ,
  loadShader ,
  initShaderProgram ,
  main ,
}
/*  Not a pure module */
